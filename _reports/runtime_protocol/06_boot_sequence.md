# START_LOGOS Boot Sequence (Static Trace)

1. **Path + flag setup** – `main()` parses CLI flags, calls `_extend_sys_path()` to append the repo root, `PXL_Gate`, and `System_Stack/Logos_AGI` to `sys.path`, and flips the dashboard phase to `init` before any imports fire ([START_LOGOS.py](START_LOGOS.py#L46-L66), [START_LOGOS.py](START_LOGOS.py#L144-L164)). This is the only place System_Stack modules become importable during bootstrap.
2. **Proof gate + identity audit** – `_run_proofs()` compiles the Coq baseline/meta suites via `PXL_Gate.ui.run_coq_pipeline.run_full_pipeline`, opens the `lem_portal` identity log, toggles the dashboard LEM flag, and (unless suppressed) rewrites the audit ledger through `PXL_Gate.ui.audit_and_emit.main(["--write"])` to persist the proof + identity state ([START_LOGOS.py](START_LOGOS.py#L54-L83)). Any portal failure raises and halts bootstrap.
3. **Dashboard + telemetry** – `_start_dashboard_from_env()` conditionally starts `logos_dashboard.app.start_dashboard`, reports listening host/port, and pre-populates agent/protocol status in the metrics surface. Failures are logged but non-fatal in order to keep the boot path moving ([START_LOGOS.py](START_LOGOS.py#L86-L111)).
4. **UI services** – unless `--no-ui` is passed, `_start_flask()` imports `PXL_Gate.ui.serve_pxl.app`, launches it in a daemon thread, and logs host/port while marking the dashboard stage as `services` ([START_LOGOS.py](START_LOGOS.py#L74-L85), [START_LOGOS.py](START_LOGOS.py#L166-L177)).
5. **System_Stack load / UIP manager** – `_start_uip_background()` pulls in `System_Operations_Protocol.startup.uip_startup.UIPManager`, spins an asyncio loop on a background thread, and keeps a handle to the manager once it reports healthy so the dashboard protocol entry can flip to `ready` ([START_LOGOS.py](START_LOGOS.py#L112-L138), [START_LOGOS.py](START_LOGOS.py#L177-L187)). This is where the broader System_Stack runtime first becomes active.
6. **Signal + shutdown wiring** – after marking the boot phase `ready`, the script installs SIGINT/SIGTERM handlers that stop the UIP loop and set a `threading.Event`, then waits inside `_wait_for_signal()` until operators terminate the process ([START_LOGOS.py](START_LOGOS.py#L168-L210)). Identity/audit artifacts remain untouched after this point unless downstream services request additional writes.
